<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`bitvec`"><meta name="keywords" content="rust, rustlang, rust-lang, bitvec"><title>bitvec - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate bitvec</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 1.0.0</li><li><a id="all-types" href="all.html">All Items</a></li></div></ul><section><div class="block"><ul><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li></ul></div></section><div id="sidebar-vars" data-name="bitvec" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../bitvec/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">bitvec</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/bitvec/lib.rs.html#1-77">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><div class="title-block" style="text-align: center;" align="center">
<h2 id="bitvec"><a href="#bitvec"><code>bitvec</code></a></h2><h3 id="a-magnifying-glass-for-memory-"><a href="#a-magnifying-glass-for-memory-">A Magnifying Glass for Memory <!-- omit in toc --></a></h3>
<p><a href="https://crates.io/crates/bitvec" title="Crate listing"><img src="https://img.shields.io/crates/v/bitvec.svg?logo=rust&amp;style=for-the-badge" alt="Crate" title="Crate badge" /></a>
<a href="https://docs.rs/bitvec/latest/bitvec" title="Crate documentation"><img src="https://img.shields.io/docsrs/bitvec/latest.svg?style=for-the-badge" alt="Documentation" title="Documentation badge" /></a>
<a href="https://github.com/bitvecto-rs/bitvec/blob/main/LICENSE.txt" title="Project license"><img src="https://img.shields.io/crates/l/bitvec.svg?style=for-the-badge" alt="License" title="License badge" /></a></p>
<p><a href="https://crates.io/crates/bitvec" title="Crate listing"><img src="https://img.shields.io/crates/dv/bitvec.svg?logo=rust&amp;style=for-the-badge" alt="Crate Downloads" title="Crate downloads" /></a>
<a href="https://github.com/bitvecto-rs/bitvec" title="Project repository"><img src="https://img.shields.io/tokei/lines/github/bitvecto-rs/bitvec?category=code&amp;style=for-the-badge" alt="Project Size" title="Project size" /></a></p>
</div>
<ol>
<li><a href="#summary">Summary</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#highlights">Highlights</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#user-stories">User Stories</a>
<ol>
<li><a href="#bit-collections">Bit Collections</a></li>
<li><a href="#bit-field-memory-access">Bit-Field Memory Access</a></li>
<li><a href="#transport-protocols">Transport Protocols</a></li>
</ol>
</li>
<li><a href="#feature-flags">Feature Flags</a></li>
<li><a href="#deeper-reading">Deeper Reading</a></li>
</ol>
<h3 id="summary"><a href="#summary">Summary</a></h3>
<p><code>bitvec</code> provides a foundational API for bitfields in Rust. It specializes
standard-library data structures (slices, arrays, and vectors of <code>bool</code>) to use
one-bit-per-<code>bool</code> storage, similar to <a href="https://en.cppreference.com/w/cpp/utility/bitset"><code>std::bitset&lt;N&gt;</code></a> and
<a href="https://en.cppreference.com/w/cpp/container/vector_bool"><code>std::vector&lt;bool&gt;</code></a> in C++.</p>
<p>Additionally, it allows a memory region to be divided into arbitrary regions of
integer storage, like <a href="https://www.erlang.org/doc/programming_examples/bit_syntax.html">binaries</a> in Erlang.</p>
<p>If you need to view memory as bit-addressed instead of byte-addressed, then
<code>bitvec</code> is the fastest, most complete, and Rust-idiomatic crate for you.</p>
<h3 id="introduction"><a href="#introduction">Introduction</a></h3>
<p>Computers do not operate on bits. The memory bus is byte-addressed, and
processors operate on register words, which are typically four to eight bytes,
or even wider. This means that when programmers wish to operate on individual
bits within a byte of memory or a word of register, they have to do so manually,
using shift and mask operations that are likely familiar to anyone who has done
this before.</p>
<p><code>bitvec</code> brings the capabilities of C++’s compact <code>bool</code> storage and Erlang’s
decomposable bit-streams to Rust, in a package that fits in with your existing
Rust idioms and in the most capable, performant, implementation possible. The
bit-stream behavior provides the logic necessary for C-style structural
bitfields, and syntax sugar for it can be found in <a href="https://crates.io/crates/deku"><code>deku</code></a>.</p>
<p><code>bitvec</code> enables you to write code for bit-addressed memory that is simple,
easy, and fast. It compiles to the same, or even better, object code than you
would get from writing shift/mask instructions manually. It leverages Rust’s
powerful reference and type systems to create a system that seamlessly bridges
single-bit addressing, precise control of in-memory layout, and Rust-native
ownership and borrowing mechanisms.</p>
<h3 id="highlights"><a href="#highlights">Highlights</a></h3>
<p><code>bitvec</code> has a number of unique capabilities related to its place as a Rust
library and as a bit-addressing system.</p>
<ul>
<li>It supports arbitrary bit-addressing, and its bit slices can be munched from
the front.</li>
<li><code>BitSlice</code> is a region type equivalent to <code>[bool]</code>, and can be described by
Rust references and thus fit into reference-based APIs.</li>
<li>Type parameters enable users to select the precise memory representation they
desire.</li>
<li>A memory model accounts for element-level aliasing and is safe for concurrent
use. In particular, the “Beware Bitfields” bug described in
<a href="https://hacks.mozilla.org/2021/04/eliminating-data-races-in-firefox-a-technical-report/" title="Mozilla Hacks article describing various concurrency bugs in FireFox">this Mozilla report</a> is simply impossible to produce.</li>
<li>Native support for atomic integers as bit-field storage.</li>
<li>Users can supply their own translation layer for memory representation if the
built-in translations are insufficient.</li>
</ul>
<p>However, it does also have some small costs associated with its capabilities:</p>
<ul>
<li><code>BitSlice</code> cannot be used as a referent type in pointers, such as <code>Box</code>, <code>Rc</code>,
or <code>Arc</code>.</li>
<li><code>BitSlice</code> cannot implement <code>IndexMut</code>, so <code>bitslice[index] = true;</code> does not
work.</li>
</ul>
<h3 id="usage"><a href="#usage">Usage</a></h3>
<p><strong>Minimum Supported Rust Version</strong>: 1.56.0</p>
<p><code>bitvec</code> strives to follow the sequence APIs in the standard library. However,
as most of its functionality is a reïmplementation that does not require the
standard library to actually have the symbols present, doing so may not require
an MSRV raise.</p>
<p>Now that <code>bitvec</code> is at 1.0, it will only raise MSRV in minor-edition releases.
If you have a pinned Rust toolchain, you should depend on <code>bitvec</code> with a
limiting minor-version constraint like <code>&quot;~1.0&quot;</code>.</p>
<p>First, depend on it in your Cargo manifest:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
bitvec = &quot;1&quot;</code></pre></div>
<blockquote>
<p>Note: <code>bitvec</code> supports <code>#![no_std]</code> targets. If you do not have <code>std</code>,
disable the default features, and explicitly restore any features that you do
have:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies.bitvec]
version = &quot;1&quot;
default-features = false
features = [&quot;atomic&quot;, &quot;alloc&quot;]</code></pre></div></blockquote>
<p>Once Cargo knows about it, bring its prelude into scope:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;</code></pre></div>
<p>You can read the <a href="https://docs.rs/bitvec/latest/bitvec/prelude">prelude reëxports</a> to see exactly which symbols are
being imported. The prelude brings in many symbols, and while name collisions
are not likely, you may wish to instead import the prelude <em>module</em> rather than
its contents:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span> <span class="kw">as</span> <span class="ident">bv</span>;</code></pre></div>
<p>You should almost certainly use type aliases to make names for specific
instantiations of <code>bitvec</code> type parameters, and use that rather than attempting
to remain generic over an <code>&lt;T: BitStore, O: BitOrder&gt;</code> pair throughout your
project.</p>
<h3 id="examples"><a href="#examples">Examples</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="comment">// All data-types have macro</span>
<span class="comment">// constructors.</span>
<span class="kw">let</span> <span class="ident">arr</span> <span class="op">=</span> <span class="macro">bitarr!</span>[<span class="ident">u32</span>, <span class="ident">Lsb0</span>; <span class="number">0</span>; <span class="number">80</span>];
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="ident">u16</span>, <span class="ident">Msb0</span>; <span class="number">0</span>; <span class="number">40</span>];

<span class="comment">// Unsigned integers (scalar, array,</span>
<span class="comment">// and slice) can be borrowed.</span>
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0x2021u16</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0xA5u8</span>, <span class="number">0x3C</span>];
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();

<span class="comment">// Bit-slices can split anywhere.</span>
<span class="kw">let</span> (<span class="ident">head</span>, <span class="ident">rest</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at</span>(<span class="number">4</span>);
<span class="macro">assert_eq!</span>(<span class="ident">head</span>, <span class="ident">bits</span>[.. <span class="number">4</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">rest</span>, <span class="ident">bits</span>[<span class="number">4</span> ..]);

<span class="comment">// And they are writable!</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">2</span>];
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="comment">// l and r each own one byte.</span>
<span class="kw">let</span> (<span class="ident">l</span>, <span class="ident">r</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at_mut</span>(<span class="number">8</span>);

<span class="comment">// but now a, b, c, and d own a nibble!</span>
<span class="kw">let</span> ((<span class="ident">a</span>, <span class="ident">b</span>), (<span class="ident">c</span>, <span class="ident">d</span>)) <span class="op">=</span> (
  <span class="ident">l</span>.<span class="ident">split_at_mut</span>(<span class="number">4</span>),
  <span class="ident">r</span>.<span class="ident">split_at_mut</span>(<span class="number">4</span>),
);

<span class="comment">// and all four of them are writable.</span>
<span class="ident">a</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
<span class="ident">b</span>.<span class="ident">set</span>(<span class="number">1</span>, <span class="bool-val">true</span>);
<span class="ident">c</span>.<span class="ident">set</span>(<span class="number">2</span>, <span class="bool-val">true</span>);
<span class="ident">d</span>.<span class="ident">set</span>(<span class="number">3</span>, <span class="bool-val">true</span>);

<span class="macro">assert!</span>(<span class="ident">bits</span>[<span class="number">0</span>]);  <span class="comment">// a[0]</span>
<span class="macro">assert!</span>(<span class="ident">bits</span>[<span class="number">5</span>]);  <span class="comment">// b[1]</span>
<span class="macro">assert!</span>(<span class="ident">bits</span>[<span class="number">10</span>]); <span class="comment">// c[2]</span>
<span class="macro">assert!</span>(<span class="ident">bits</span>[<span class="number">15</span>]); <span class="comment">// d[3]</span>

<span class="comment">// `BitSlice` is accessed by reference,</span>
<span class="comment">// which means it respects NLL styles.</span>
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, [<span class="number">0x21u8</span>, <span class="number">0x84</span>]);

<span class="comment">// Furthermore, bit-slices can store</span>
<span class="comment">// ordinary integers:</span>
<span class="kw">let</span> <span class="ident">eight</span> <span class="op">=</span> [<span class="number">0u8</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">20</span>, <span class="number">24</span>, <span class="number">28</span>];
<span class="comment">//           a    b  c  d   e   f   g   h</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">five</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">5</span>];
<span class="kw">for</span> (<span class="ident">slot</span>, <span class="ident">byte</span>) <span class="kw">in</span> <span class="ident">five</span>
  .<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>()
  .<span class="ident">chunks_mut</span>(<span class="number">5</span>)
  .<span class="ident">zip</span>(<span class="ident">eight</span>.<span class="ident">iter</span>().<span class="ident">copied</span>())
{
  <span class="ident">slot</span>.<span class="ident">store_be</span>(<span class="ident">byte</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">slot</span>.<span class="ident">load_be</span>::<span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>(), <span class="ident">byte</span>);
}

<span class="macro">assert_eq!</span>(<span class="ident">five</span>, [
  <span class="number">0b00000_001</span>,
<span class="comment">//  aaaaa bbb</span>
  <span class="number">0b00_01000_0</span>,
<span class="comment">//  bb ccccc d</span>
  <span class="number">0b1100_1000</span>,
<span class="comment">//  dddd eeee</span>
  <span class="number">0b0_10100_11</span>,
<span class="comment">//  e fffff gg</span>
  <span class="number">0b000_11100</span>,
<span class="comment">//  ggg hhhhh</span>
]);</code></pre></div>
<p>The <code>BitSlice</code> type is a view that alters the behavior of a borrowed memory
region. It is never held directly, but only by references (created by borrowing
integer memory) or the <code>BitArray</code> value type. In addition, the presence of a
dynamic allocator enables the <code>BitBox</code> and <code>BitVec</code> buffer types, which can be
used for more advanced buffer manipulation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
<span class="kw">fn</span> <span class="ident">main</span>() {

<span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">u8</span>, <span class="ident">Msb0</span>;];
<span class="ident">bv</span>.<span class="ident">push</span>(<span class="bool-val">false</span>);
<span class="ident">bv</span>.<span class="ident">push</span>(<span class="bool-val">true</span>);
<span class="ident">bv</span>.<span class="ident">extend</span>([<span class="bool-val">false</span>; <span class="number">4</span>].<span class="ident">iter</span>());
<span class="ident">bv</span>.<span class="ident">extend</span>(<span class="kw-2">&amp;</span><span class="number">15u8</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()[.. <span class="number">4</span>]);

<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">as_raw_slice</span>(), <span class="kw-2">&amp;</span>[
  <span class="number">0b01_0000_11</span>, <span class="number">0b11_000000</span>
<span class="comment">//                   ^ dead</span>
]);

}</code></pre></div>
<p>While place expressions like <code>bits[index] = value;</code> are not available, <code>bitvec</code>
instead provides a proxy structure that can be used as <em>nearly</em> an <code>&amp;mut bit</code>
reference:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>];
<span class="comment">// `bit` is not a reference, so</span>
<span class="comment">// it must be bound with `mut`.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bit</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">get_mut</span>(<span class="number">0</span>).<span class="ident">unwrap</span>();
<span class="macro">assert!</span>(<span class="op">!</span><span class="kw-2">*</span><span class="ident">bit</span>);
<span class="kw-2">*</span><span class="ident">bit</span> <span class="op">=</span> <span class="bool-val">true</span>;
<span class="macro">assert!</span>(<span class="kw-2">*</span><span class="ident">bit</span>);
<span class="comment">// `bit` is not a reference,</span>
<span class="comment">// so NLL rules do not apply.</span>
<span class="ident">drop</span>(<span class="ident">bit</span>);
<span class="macro">assert!</span>(<span class="ident">bits</span>[<span class="number">0</span>]);</code></pre></div>
<p>The <code>bitvec</code> data types implement a complete replacement for their
standard-library counterparts, including all of the inherent methods, traits,
and operator behaviors.</p>
<h3 id="user-stories"><a href="#user-stories">User Stories</a></h3>
<p>Uses of <code>bitvec</code> generally fall into three major genres.</p>
<ul>
<li>compact, fast, <code>usize =&gt; bit</code> collections</li>
<li>truncated integer storage</li>
<li>precise control of memory layout</li>
</ul>
<h4 id="bit-collections"><a href="#bit-collections">Bit Collections</a></h4>
<p>At its most basic, <code>bitvec</code> provides sequence types analogous to the standard
library’s <code>bool</code> collections. The default behavior is optimized for fast memory
access and simple codegen, and can compact <code>[bool]</code> or <code>Vec&lt;bool&gt;</code> with minimal
overhead.</p>
<p>While <code>bitvec</code> does not attempt to take advantage of SIMD or other vectorized
instructions in its default work, its codegen should be a good candidate for
autovectorization in LLVM. If explicit vectorization is important to you, please
<a href="https://github.com/bitvecto-rs/bitvec/issues/new">file an issue</a>.</p>
<p>Example uses might be implementing a Sieve of Eratosthenes to store primes, or
other collections that test a yes/no property of a number; or replacing
<code>Vec&lt;Option&lt;T&gt;&gt;</code> with <code>(BitVec, Vec&lt;MaybeUninit&lt;T&gt;&gt;</code>).</p>
<p>To get started, you can perform basic text replacement on your project.
Translate any existing types as follows:</p>
<ul>
<li><code>[bool; N]</code> becomes <code>BitArray</code></li>
<li><code>[bool]</code> becomes <code>BitSlice</code></li>
<li><code>Vec&lt;bool&gt;</code> becomes <code>BitVec</code></li>
<li><code>Box&lt;[bool]&gt;</code> becomes <code>BitBox</code></li>
</ul>
<p>and then follow any compiler errors that arise.</p>
<h4 id="bit-field-memory-access"><a href="#bit-field-memory-access">Bit-Field Memory Access</a></h4>
<p>A single bit of information has very few uses. <code>bitvec</code> also enables you to
store integers wider than a single bit, by selecting a bit-slice and using the
<a href="https://docs.rs/bitvec/latest/bitvec/field/trait.BitField.html"><code>BitField</code></a> trait on it. You can store and retrieve both unsigned and signed
integers, as long as the ordering type parameter is <a href="https://docs.rs/bitvec/latest/bitvec/order/struct.Lsb0.html"><code>Lsb0</code></a> or <a href="https://docs.rs/bitvec/latest/bitvec/order/struct.Msb0.html"><code>Msb0</code></a>.</p>
<p>If your bit-field storage buffers are never serialized for exchange between
machines, then you can get away with using the default type parameters and
unadorned load/store methods. While the in-memory layout of stored integers may
be surprising if directly inspected, the overall behavior should be optimal for
your target.</p>
<p>Remember: <code>bitvec</code> only provides array place expressions, using integer start
and end points. You can use <a href="https://crates.io/crates/deku"><code>deku</code></a> if you want C-style named structural fields
with bit-field memory storage.</p>
<p>However, if you are de/serializing buffers for transport, then you fall into the
third category.</p>
<h4 id="transport-protocols"><a href="#transport-protocols">Transport Protocols</a></h4>
<p>Many protocols use sub-element fields in order to save space in transport; for
example, TCP headers have single-bit and 4-bit fields in order to pack all the
needed information into a desirable amount of space. In C or Erlang, these TCP
protocol fields could be mapped by record fields in the language. In Rust, they
can be mapped by indexing into a bit-slice.</p>
<p>When using <code>bitvec</code> to manage protocol buffers, you will need to select the
exact type parameters that match your memory layout. For instance, TCP uses
<code>&lt;u8, Msb0&gt;</code>, while IPv6 on a little-endian machine uses <code>&lt;u32, Lsb0&gt;</code>. Once you
have done this, you can replace all of your <code>(memory &amp; mask) &gt;&gt; shift</code> or
<code>memory |= (value &amp; mask) &lt;&lt; shift</code> expressions with <code>memory[start .. end]</code>.</p>
<p>As a direct example, the Itanium instruction set IA-64 uses very-long
instruction words containing three 41-bit fields in a <code>[u8; 16]</code>. One IA-64
disassembler replaced its manual shift/mask implementation with <code>bitvec</code> range
indexing, taking the bit numbers directly from the datasheet, and observed that
their code was both easier to maintain and also had better performance as a
result!</p>
<h3 id="feature-flags"><a href="#feature-flags">Feature Flags</a></h3>
<p><code>bitvec</code> has a few Cargo features that govern its API surface. The default
feature set is:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies.bitvec]
version = &quot;1&quot;
features = [
  &quot;alloc&quot;,
  &quot;atomic&quot;,
  &quot;std&quot;,
]</code></pre></div>
<p>Use <code>default-features = false</code> to disable all of them, then <code>features = []</code> to
restore the ones you need.</p>
<ul>
<li>
<p><code>alloc</code>: This links against the <code>alloc</code> distribution crate, and provides the
<code>BitVec</code> and <code>BitBox</code> types. It can be used on <code>#![no_std]</code> targets that
possess a dynamic allocator but not an operating system.</p>
</li>
<li>
<p><code>atomic</code>: This controls whether atomic instructions can be used for aliased
memory. <code>bitvec</code> uses the <a href="https://crates.io/crates/radium"><code>radium</code></a> crate to perform automatic detection of
atomic capability, and targets that do not possess atomic instructions can
still function with this feature <em>enabled</em>. Its only effect is that targets
which do have atomic instructions may choose to disable it and enforce
single-threaded behavior that never incurs atomic synchronization.</p>
</li>
<li>
<p><code>serde</code>: This enables the de/serialization of <code>bitvec</code> buffers through the
<code>serde</code> system. This can be useful if you need to transmit <code>usize =&gt; bool</code>
collections.</p>
</li>
<li>
<p><code>std</code>: This provides some <code>std::io::{Read,Write}</code> implementations, as well as
<code>std::error::Error</code> for the various error types. It is otherwise unnecessary.</p>
</li>
</ul>
<h3 id="deeper-reading"><a href="#deeper-reading">Deeper Reading</a></h3>
<p>The <a href="https://docs.rs/bitvec/latest/bitvec">API Documentation</a> explores <code>bitvec</code>’s usage and implementation in
great detail. In particular, you should read the documentation for the
<a href="https://docs.rs/bitvec/latest/bitvec/order/index.html"><code>order</code></a>, <a href="https://docs.rs/bitvec/latest/bitvec/store/index.html"><code>store</code></a>, and <a href="https://docs.rs/bitvec/latest/bitvec/field/index.html"><code>field</code></a> modules, as well as the <a href="https://docs.rs/bitvec/latest/bitvec/slice/struct.BitSlice.html"><code>BitSlice</code></a> and
<a href="https://docs.rs/bitvec/latest/bitvec/array/struct.BitArray.html"><code>BitArray</code></a> types.</p>
<p>In addition, the <a href="https://bitvecto-rs.github.io/bitvec/">user guide</a> explores the philosophical and academic
concepts behind <code>bitvec</code>’s construction, its goals, and the more intricate parts
of its behavior.</p>
<p>While you should be able to get started with <code>bitvec</code> with only dropping it into
your code and using the same habits you have with the standard library, both of
these resources contain all of the information needed to understand what it
does, how it works, and how it can be useful to you.</p>
<!-- Badges -->
<!-- Documentation -->
<!-- External References -->
<style type="text/css">
.title-block {
  text-align: center;
}
</style></div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="access/index.html" title="bitvec::access mod">access</a></div><div class="item-right docblock-short"><p>Memory Bus Access Management</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="array/index.html" title="bitvec::array mod">array</a></div><div class="item-right docblock-short"><p>Statically-Allocated, Fixed-Size, Bit Buffer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="boxed/index.html" title="bitvec::boxed mod">boxed</a></div><div class="item-right docblock-short"><p>Heap-Allocated, Fixed-Size, Bit Buffer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="domain/index.html" title="bitvec::domain mod">domain</a></div><div class="item-right docblock-short"><p>Memory Region Description</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="field/index.html" title="bitvec::field mod">field</a></div><div class="item-right docblock-short"><p>Bit-Field Memory Slots</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="index/index.html" title="bitvec::index mod">index</a></div><div class="item-right docblock-short"><p>Bit Indices</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="macros/index.html" title="bitvec::macros mod">macros</a></div><div class="item-right docblock-short"><p>Constructor Macros</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="mem/index.html" title="bitvec::mem mod">mem</a></div><div class="item-right docblock-short"><p>Memory Element Descriptions</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="order/index.html" title="bitvec::order mod">order</a></div><div class="item-right docblock-short"><p>In-Element Bit Ordering</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="prelude/index.html" title="bitvec::prelude mod">prelude</a></div><div class="item-right docblock-short"><p>Symbol Export</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="ptr/index.html" title="bitvec::ptr mod">ptr</a></div><div class="item-right docblock-short"><p>Raw Pointer Implementation</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="slice/index.html" title="bitvec::slice mod">slice</a></div><div class="item-right docblock-short"><p>Bit-Addressable Memory Regions</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="store/index.html" title="bitvec::store mod">store</a></div><div class="item-right docblock-short"><p>Storage Memory Description</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="vec/index.html" title="bitvec::vec mod">vec</a></div><div class="item-right docblock-short"><p>Dynamically-Allocated, Adjustable-Size, Bit Buffer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="view/index.html" title="bitvec::view mod">view</a></div><div class="item-right docblock-short"><p>Bit View Adapters</p>
</div></div></div><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.BitArr.html" title="bitvec::BitArr macro">BitArr</a></div><div class="item-right docblock-short"><p>Bit-Array Type Definition</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.bitarr.html" title="bitvec::bitarr macro">bitarr</a></div><div class="item-right docblock-short"><p>Bit-Array Value Constructor</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.bitbox.html" title="bitvec::bitbox macro">bitbox</a></div><div class="item-right docblock-short"><p>Boxed Bit-Slice Constructor</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.bits.html" title="bitvec::bits macro">bits</a></div><div class="item-right docblock-short"><p>Bit-Slice Region Constructor</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.bitvec.html" title="bitvec::bitvec macro">bitvec</a></div><div class="item-right docblock-short"><p>Bit-Vector Constructor</p>
</div></div></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="bitvec" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.61.0 (fe5b13d68 2022-05-18)" ></div>
</body></html>