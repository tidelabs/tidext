<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This small, zero-dependency crate helps you to parse input strings and slices by building on the [`Iterator`] interface."><meta name="keywords" content="rust, rustlang, rust-lang, yap"><title>yap - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-6827029ac823cab7.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-ebce58d0a40c3431.css"><link rel="stylesheet" disabled href="../static.files/dark-f23faae4a2daf9a6.css"><link rel="stylesheet" disabled href="../static.files/ayu-8af5e100b21cd173.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-c55e1eb52e1886b4.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../yap/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../yap/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate yap</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.7.2</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a class="mod" href="#">yap</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/yap/lib.rs.html#1-117">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This small, zero-dependency crate helps you to parse input strings and slices by building on the <a href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html" title="Iterator"><code>Iterator</code></a>
interface.</p>
<p>The aim of this crate is to provide the sorts of functions you’d come to expect from a parser
combinator library, but without immersing you into a world of parser combinators, and forcing you
to use a novel return type, library-provided errors or parser-combinator based control flow. It hopes
to sacrifice conciseness in exchange for simplicity.</p>
<p><strong>Some specific features/goals:</strong></p>
<ul>
<li>Lots of examples. Every function provided comes with example usage.</li>
<li>Prioritise simplicity at the cost of verbosity.</li>
<li>Be iterator-centric. Where applicable, combinators return iterators, so you can lean on the <a href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html" title="Iterator"><code>Iterator</code></a>
interface to parse as much or as little as you want from the input, and collect up the output however
you wish.</li>
<li>Allow user defined errors to be returned anywhere that it might make sense. Some functions have <code>_err</code>
variants incase you need error information when they don’t otherwise hand back errors for simplicity.</li>
<li>Location information should always be available, so that you can tell users where something went wrong.
see <a href="trait.Tokens.html#method.offset" title="Tokens::offset"><code>Tokens::offset</code></a></li>
<li>Backtracking by default. Coming from Haskell’s Parsec, this feels like the sensible default. It means that
if one of the provided parsing functions fails to parse what you asked for, it won’t consume any input
trying.</li>
<li>Expose all of the “low level” functions. You can save and rewind to locations as needed (see <a href="trait.Tokens.html#tymethod.location" title="Tokens::location"><code>Tokens::location</code></a>),
and implement any of the provided functions using these primitives.</li>
<li>Aims to be “fairly quick”. Avoids allocations (and allows you to do the same via the iterator-centric interface).
If you need “as fast as you can get”, there are probably quicker alternatives.</li>
</ul>
<p>Have a look at the <a href="trait.Tokens.html" title="Tokens"><code>Tokens</code></a> trait for all of the parsing methods made available, and examples for each.</p>
<p>Have a look in the <code>examples</code> folder for more in depth examples.</p>
<h2 id="example"><a href="#example">Example</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{
    <span class="comment">// This trait has all of the parsing methods on it:
    </span>Tokens,
    <span class="comment">// Allows you to use `.into_tokens()` on strings and slices,
    // to get an instance of the above:
    </span>IntoTokens
};

<span class="comment">// Step 1: convert our input into something implementing `Tokens`
// ================================================================

</span><span class="kw">let </span><span class="kw-2">mut </span>tokens = <span class="string">&quot;10 + 2 x 12-4,foobar&quot;</span>.into_tokens();

<span class="comment">// Step 2: Parse some things from our tokens
// =========================================

</span><span class="attr">#[derive(PartialEq,Debug)]
</span><span class="kw">enum </span>Op { Plus, Minus, Multiply }
<span class="attr">#[derive(PartialEq,Debug)]
</span><span class="kw">enum </span>OpOrDigit { Op(Op), Digit(u32) }

<span class="comment">// The `Tokens` trait builds on `Iterator`, so we get a `next` method.
</span><span class="kw">fn </span>parse_op(t: <span class="kw-2">&amp;mut </span><span class="kw">impl </span>Tokens&lt;Item=char&gt;) -&gt; <span class="prelude-ty">Option</span>&lt;Op&gt; {
    <span class="kw">match </span>t.next()<span class="question-mark">? </span>{
        <span class="string">&#39;-&#39; </span>=&gt; <span class="prelude-val">Some</span>(Op::Minus),
        <span class="string">&#39;+&#39; </span>=&gt; <span class="prelude-val">Some</span>(Op::Plus),
        <span class="string">&#39;x&#39; </span>=&gt; <span class="prelude-val">Some</span>(Op::Multiply),
        <span class="kw">_ </span>=&gt; <span class="prelude-val">None
    </span>}
}

<span class="comment">// We also get other useful functions..
</span><span class="kw">fn </span>parse_digits(t: <span class="kw-2">&amp;mut </span><span class="kw">impl </span>Tokens&lt;Item=char&gt;) -&gt; <span class="prelude-ty">Option</span>&lt;u32&gt; {
    <span class="kw">let </span>s: String = t
        .tokens_while(|c| c.is_digit(<span class="number">10</span>))
        .collect();
    s.parse().ok()
}

<span class="comment">// As well as combinator functions like `sep_by_all` and `surrounded_by`..
</span><span class="kw">let </span>op_or_digit = tokens.sep_by_all(
    |t| t.surrounded_by(
        |t| parse_digits(t).map(OpOrDigit::Digit),
        |t| { t.skip_tokens_while(|c| c.is_ascii_whitespace()); }
    ),
    |t| parse_op(t).map(OpOrDigit::Op)
);

<span class="comment">// Now we&#39;ve parsed our input into OpOrDigits, let&#39;s calculate the result..
</span><span class="kw">let </span><span class="kw-2">mut </span>current_op = Op::Plus;
<span class="kw">let </span><span class="kw-2">mut </span>current_digit = <span class="number">0</span>;
<span class="kw">for </span>d <span class="kw">in </span>op_or_digit {
    <span class="kw">match </span>d {
        OpOrDigit::Op(op) =&gt; {
            current_op = op
        },
        OpOrDigit::Digit(n) =&gt; {
            <span class="kw">match </span>current_op {
                Op::Plus =&gt; { current_digit += n },
                Op::Minus =&gt; { current_digit -= n },
                Op::Multiply =&gt; { current_digit <span class="kw-2">*</span>= n },
            }
        },
    }
}
<span class="macro">assert_eq!</span>(current_digit, <span class="number">140</span>);

<span class="comment">// Step 3: do whatever you like with the rest of the input!
// ========================================================

// This is available on the concrete type that strings
// are converted into (rather than on the `Tokens` trait):
</span><span class="kw">let </span>remaining = tokens.remaining();

<span class="macro">assert_eq!</span>(remaining, <span class="string">&quot;,foobar&quot;</span>);</code></pre></div>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="types/index.html" title="yap::types mod">types</a></div><div class="item-right docblock-short">This module contains types which implement the <a href="trait.Tokens.html" title="Tokens"><code>Tokens</code></a> interface. You
won’t often need to import this module unless you wish to explicitly name
the types in question.</div></div></div><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.one_of.html" title="yap::one_of macro">one_of</a></div><div class="item-right docblock-short">Pass the provided tokens into each expression, one after the other.
Return the first not-<code>None</code> result.</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.IntoTokens.html" title="yap::IntoTokens trait">IntoTokens</a></div><div class="item-right docblock-short">A trait that is implemented by anything which can be converted into an
object implementing the <a href="trait.Tokens.html" title="Tokens"><code>Tokens</code></a> trait.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.TokenLocation.html" title="yap::TokenLocation trait">TokenLocation</a></div><div class="item-right docblock-short">Calling <a href="trait.Tokens.html#tymethod.location" title="Tokens::location()"><code>Tokens::location()</code></a> returns an object that implements this trait.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Tokens.html" title="yap::Tokens trait">Tokens</a></div><div class="item-right docblock-short">The tokens trait builds on the <a href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html" title="Iterator"><code>Iterator</code></a> trait, and adds a bunch of useful methods
for parsing tokens from the underlying iterable type.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="yap" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.1 (d5a82bbd2 2023-02-07)" data-search-js="search-444266647c4dba98.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>