<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The tokens trait builds on the [`Iterator`] trait, and adds a bunch of useful methods for parsing tokens from the underlying iterable type."><meta name="keywords" content="rust, rustlang, rust-lang, Tokens"><title>Tokens in yap - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-6827029ac823cab7.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-ebce58d0a40c3431.css"><link rel="stylesheet" disabled href="../static.files/dark-f23faae4a2daf9a6.css"><link rel="stylesheet" disabled href="../static.files/ayu-8af5e100b21cd173.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-c55e1eb52e1886b4.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../yap/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../yap/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2 class="location"><a href="#">Tokens</a></h2><div class="sidebar-elems"><section><h3><a href="#required-associated-types">Required Associated Types</a></h3><ul class="block"><li><a href="#associatedtype.Location">Location</a></li></ul><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.is_at_location">is_at_location</a></li><li><a href="#tymethod.location">location</a></li><li><a href="#tymethod.set_location">set_location</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.many">many</a></li><li><a href="#method.many_err">many_err</a></li><li><a href="#method.offset">offset</a></li><li><a href="#method.one_of_tokens">one_of_tokens</a></li><li><a href="#method.optional">optional</a></li><li><a href="#method.peek">peek</a></li><li><a href="#method.sep_by">sep_by</a></li><li><a href="#method.sep_by_all">sep_by_all</a></li><li><a href="#method.sep_by_all_err">sep_by_all_err</a></li><li><a href="#method.sep_by_err">sep_by_err</a></li><li><a href="#method.skip_many">skip_many</a></li><li><a href="#method.skip_many1">skip_many1</a></li><li><a href="#method.skip_optional">skip_optional</a></li><li><a href="#method.skip_tokens_while">skip_tokens_while</a></li><li><a href="#method.slice">slice</a></li><li><a href="#method.surrounded_by">surrounded_by</a></li><li><a href="#method.token">token</a></li><li><a href="#method.tokens">tokens</a></li><li><a href="#method.tokens_while">tokens_while</a></li><li><a href="#method.with_context">with_context</a></li><li><a href="#method.with_context_mut">with_context_mut</a></li></ul><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In yap</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Trait <a href="index.html">yap</a>::<wbr><a class="trait" href="#">Tokens</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/yap/tokens.rs.html#31-808">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><div class="item-decl"><pre class="rust trait"><code>pub trait Tokens: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> + <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> {
    type <a href="#associatedtype.Location" class="associatedtype">Location</a>: <a class="trait" href="trait.TokenLocation.html" title="trait yap::TokenLocation">TokenLocation</a> + <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> + <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> + <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>;

<details class="rustdoc-toggle type-contents-toggle"><summary class="hideme"><span>Show 24 methods</span></summary>    fn <a href="#tymethod.location" class="fn">location</a>(&amp;self) -&gt; Self::<a class="associatedtype" href="trait.Tokens.html#associatedtype.Location" title="type yap::Tokens::Location">Location</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.set_location" class="fn">set_location</a>(&amp;mut self, location: Self::<a class="associatedtype" href="trait.Tokens.html#associatedtype.Location" title="type yap::Tokens::Location">Location</a>);
<span class="item-spacer"></span>    fn <a href="#tymethod.is_at_location" class="fn">is_at_location</a>(&amp;self, location: &amp;Self::<a class="associatedtype" href="trait.Tokens.html#associatedtype.Location" title="type yap::Tokens::Location">Location</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.bool.html">bool</a>;

    fn <a href="#method.with_context" class="fn">with_context</a>&lt;C&gt;(self, context: C) -&gt; <a class="struct" href="types/struct.WithContext.html" title="struct yap::types::WithContext">WithContext</a>&lt;Self, C&gt; <a href="#" class="notable-traits" data-ty="WithContext&lt;Self, C&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.with_context_mut" class="fn">with_context_mut</a>&lt;C&gt;(&amp;mut self, context: C) -&gt; <a class="struct" href="types/struct.WithContextMut.html" title="struct yap::types::WithContextMut">WithContextMut</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self, C&gt; <a href="#" class="notable-traits" data-ty="WithContextMut&lt;&amp;mut Self, C&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.slice" class="fn">slice</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from: Self::<a class="associatedtype" href="trait.Tokens.html#associatedtype.Location" title="type yap::Tokens::Location">Location</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to: Self::<a class="associatedtype" href="trait.Tokens.html#associatedtype.Location" title="type yap::Tokens::Location">Location</a><br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; Slice&lt;'_, Self&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.offset" class="fn">offset</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.usize.html">usize</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.peek" class="fn">peek</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.token" class="fn">token</a>&lt;I&gt;(&amp;mut self, t: I) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.bool.html">bool</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;</span>,
    { ... }
<span class="item-spacer"></span>    fn <a href="#method.tokens" class="fn">tokens</a>&lt;It&gt;(&amp;mut self, ts: It) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.bool.html">bool</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a>: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;</span>,
    { ... }
<span class="item-spacer"></span>    fn <a href="#method.one_of_tokens" class="fn">one_of_tokens</a>&lt;It&gt;(&amp;mut self, ts: It) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a>: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;</span>,
    { ... }
<span class="item-spacer"></span>    fn <a href="#method.tokens_while" class="fn">tokens_while</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; TokensWhile&lt;'_, Self, F&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.bool.html">bool</a></span>,
    { ... }
<span class="item-spacer"></span>    fn <a href="#method.skip_tokens_while" class="fn">skip_tokens_while</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.usize.html">usize</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.bool.html">bool</a></span>,
    { ... }
<span class="item-spacer"></span>    fn <a href="#method.many" class="fn">many</a>&lt;F, Output&gt;(&amp;mut self, parser: F) -&gt; Many&lt;'_, Self, F&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Output&gt;</span>,
    { ... }
<span class="item-spacer"></span>    fn <a href="#method.many_err" class="fn">many_err</a>&lt;F, Output, E&gt;(&amp;mut self, parser: F) -&gt; ManyErr&lt;'_, Self, F&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Output, E&gt;</span>,
    { ... }
<span class="item-spacer"></span>    fn <a href="#method.skip_many" class="fn">skip_many</a>&lt;F&gt;(&amp;mut self, parser: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.usize.html">usize</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.bool.html">bool</a></span>,
    { ... }
<span class="item-spacer"></span>    fn <a href="#method.skip_many1" class="fn">skip_many1</a>&lt;F, E, Ignored&gt;(&amp;mut self, parser: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.usize.html">usize</a>, E&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Ignored, E&gt;</span>,
    { ... }
<span class="item-spacer"></span>    fn <a href="#method.sep_by" class="fn">sep_by</a>&lt;F, S, Output&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parser: F,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;separator: S<br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; SepBy&lt;'_, Self, F, S&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Output&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.bool.html">bool</a></span>,
    { ... }
<span class="item-spacer"></span>    fn <a href="#method.sep_by_err" class="fn">sep_by_err</a>&lt;F, S, E, Output&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parser: F,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;separator: S<br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; SepByErr&lt;'_, Self, F, S&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Output, E&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.bool.html">bool</a></span>,
    { ... }
<span class="item-spacer"></span>    fn <a href="#method.sep_by_all" class="fn">sep_by_all</a>&lt;F, S, Output&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parser: F,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;separator: S<br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; SepByAll&lt;'_, Self, F, S, Output&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Output&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Output&gt;</span>,
    { ... }
<span class="item-spacer"></span>    fn <a href="#method.sep_by_all_err" class="fn">sep_by_all_err</a>&lt;F, S, Output, E&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parser: F,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;separator: S<br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; SepByAllErr&lt;'_, Self, F, S, Output&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Output, E&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Output&gt;</span>,
    { ... }
<span class="item-spacer"></span>    fn <a href="#method.surrounded_by" class="fn">surrounded_by</a>&lt;F, S, Output&gt;(&amp;mut self, parser: F, surrounding: S) -&gt; Output<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; Output,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self)</span>,
    { ... }
<span class="item-spacer"></span>    fn <a href="#method.optional" class="fn">optional</a>&lt;F, Output&gt;(&amp;mut self, f: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Output&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Output&gt;</span>,
    { ... }
<span class="item-spacer"></span>    fn <a href="#method.skip_optional" class="fn">skip_optional</a>&lt;F&gt;(&amp;mut self, f: F)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self)</span>,
    { ... }
</details>}</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The tokens trait builds on the <a href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html" title="Iterator"><code>Iterator</code></a> trait, and adds a bunch of useful methods
for parsing tokens from the underlying iterable type.</p>
</div></details><h2 id="required-associated-types" class="small-section-header">Required Associated Types<a href="#required-associated-types" class="anchor">§</a></h2><div class="methods"><details class="rustdoc-toggle method-toggle" open><summary><section id="associatedtype.Location" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#35">source</a><h4 class="code-header">type <a href="#associatedtype.Location" class="associatedtype">Location</a>: <a class="trait" href="trait.TokenLocation.html" title="trait yap::TokenLocation">TokenLocation</a> + <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> + <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> + <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a></h4></section></summary><div class="docblock"><p>An object which can be used to reset the token stream
to some position.</p>
</div></details></div><h2 id="required-methods" class="small-section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="rustdoc-toggle method-toggle" open><summary><section id="tymethod.location" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#63">source</a><h4 class="code-header">fn <a href="#tymethod.location" class="fn">location</a>(&amp;self) -&gt; Self::<a class="associatedtype" href="trait.Tokens.html#associatedtype.Location" title="type yap::Tokens::Location">Location</a></h4></section></summary><div class="docblock"><p>Return a “location” pointer. This can be passed to <a href="trait.Tokens.html#tymethod.set_location" title="Tokens::set_location"><code>Tokens::set_location</code></a>
to set the tokens location back to the state at the time it was handed out.
If the <a href="trait.TokenLocation.html" title="crate::TokenLocation"><code>crate::TokenLocation</code></a> trait is in scope, you can also call the
<a href="trait.TokenLocation.html#tymethod.offset" title="crate::TokenLocation::offset()"><code>crate::TokenLocation::offset()</code></a> method on it to obtain the current offset.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens, TokenLocation };

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;abcde&quot;</span>.into_tokens();

<span class="kw">let </span>location = s.location();

<span class="macro">assert_eq!</span>(s.next().unwrap(), <span class="string">&#39;a&#39;</span>);
<span class="macro">assert_eq!</span>(s.location().offset(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(s.next().unwrap(), <span class="string">&#39;b&#39;</span>);
<span class="macro">assert_eq!</span>(s.location().offset(), <span class="number">2</span>);

s.set_location(location);

<span class="macro">assert_eq!</span>(s.next().unwrap(), <span class="string">&#39;a&#39;</span>);
<span class="macro">assert_eq!</span>(s.location().offset(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(s.next().unwrap(), <span class="string">&#39;b&#39;</span>);
<span class="macro">assert_eq!</span>(s.location().offset(), <span class="number">2</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="tymethod.set_location" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#66">source</a><h4 class="code-header">fn <a href="#tymethod.set_location" class="fn">set_location</a>(&amp;mut self, location: Self::<a class="associatedtype" href="trait.Tokens.html#associatedtype.Location" title="type yap::Tokens::Location">Location</a>)</h4></section></summary><div class="docblock"><p>Set the tokens to the location provided. See <a href="trait.Tokens.html#tymethod.location" title="Tokens::location"><code>Tokens::location</code></a>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="tymethod.is_at_location" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#84">source</a><h4 class="code-header">fn <a href="#tymethod.is_at_location" class="fn">is_at_location</a>(&amp;self, location: &amp;Self::<a class="associatedtype" href="trait.Tokens.html#associatedtype.Location" title="type yap::Tokens::Location">Location</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Return true if the current cursor location matches the location given, or false
otherwise.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;abc&quot;</span>.into_tokens();
<span class="kw">let </span>location = s.location();
<span class="macro">assert_eq!</span>(s.is_at_location(<span class="kw-2">&amp;</span>location), <span class="bool-val">true</span>);
s.next();
<span class="macro">assert_eq!</span>(s.is_at_location(<span class="kw-2">&amp;</span>location), <span class="bool-val">false</span>);
s.set_location(location);
<span class="macro">assert_eq!</span>(s.is_at_location(<span class="kw-2">&amp;</span>location), <span class="bool-val">true</span>);</code></pre></div>
</div></details></div><h2 id="provided-methods" class="small-section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.with_context" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#110-112">source</a><h4 class="code-header">fn <a href="#method.with_context" class="fn">with_context</a>&lt;C&gt;(self, context: C) -&gt; <a class="struct" href="types/struct.WithContext.html" title="struct yap::types::WithContext">WithContext</a>&lt;Self, C&gt; <a href="#" class="notable-traits" data-ty="WithContext&lt;Self, C&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Attach some context to your tokens. The returned struct, <a href="types/struct.WithContext.html" title="WithContext"><code>WithContext</code></a>, also implements
<a href="trait.Tokens.html" title="Tokens"><code>Tokens</code></a>, and so has can be used in much the same way. Since this consumes your tokens, it’s
better suited to permanent context that you’d like throughout the parsing.</p>
<p>See <a href="trait.Tokens.html#method.with_context_mut" title="Tokens::with_context_mut"><code>Tokens::with_context_mut</code></a> for a version that’s easier to attach temporary context with.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens, types::WithContext };

<span class="kw">fn </span>skip_digits(toks: <span class="kw-2">&amp;mut </span>WithContext&lt;<span class="kw">impl </span>Tokens&lt;Item=char&gt;, usize&gt;) {
    <span class="kw">let </span>n_skipped = toks.skip_tokens_while(|c| c.is_digit(<span class="number">10</span>));
    <span class="kw-2">*</span>toks.context_mut() += n_skipped;
}

<span class="kw">let </span><span class="kw-2">mut </span>tokens = <span class="string">&quot;123abc456&quot;</span>.into_tokens().with_context(<span class="number">0usize</span>);

skip_digits(<span class="kw-2">&amp;mut </span>tokens);
tokens.skip_tokens_while(|c| c.is_alphabetic());
skip_digits(<span class="kw-2">&amp;mut </span>tokens);

<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>tokens.context(), <span class="number">6</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.with_context_mut" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#156-158">source</a><h4 class="code-header">fn <a href="#method.with_context_mut" class="fn">with_context_mut</a>&lt;C&gt;(&amp;mut self, context: C) -&gt; <a class="struct" href="types/struct.WithContextMut.html" title="struct yap::types::WithContextMut">WithContextMut</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self, C&gt; <a href="#" class="notable-traits" data-ty="WithContextMut&lt;&amp;mut Self, C&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Unlike <a href="trait.Tokens.html#method.with_context" title="Tokens::with_context"><code>Tokens::with_context</code></a>, which consumes the tokens, this borrows them mutably, allowing it to
be used when you only have a mutable reference to tokens (which is a common function signature to use),
and making it better suited to attaching temporary contexts.</p>
<p>Be aware that if you attach context in a function called recursively, the type checker may shout at you
for contructing a type like <code>WithContextMut&lt;WithContextMut&lt;WithContextMut&lt;..&gt;&gt;&gt;</code>. In these cases, you
can “break the cycle” by removing the original <code>WithContextMut</code> by using
<a href="types/struct.WithContextMut.html#method.into_parts" title="crate::types::WithContextMut::into_parts()"><code>crate::types::WithContextMut::into_parts()</code></a> before wrapping the tokens in a new context for the recursive
call.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="kw">fn </span>count_digit_comma_calls(toks: <span class="kw-2">&amp;mut </span><span class="kw">impl </span>Tokens&lt;Item=char&gt;) -&gt; (u8, u8) {
    <span class="kw">let </span><span class="kw-2">mut </span>counts = (<span class="number">0u8</span>, <span class="number">0u8</span>);
    toks.with_context_mut(<span class="kw-2">&amp;mut </span>counts).sep_by(
        |t| {
            t.context_mut().<span class="number">0 </span>+= <span class="number">1</span>;
            <span class="kw">let </span>n_skipped = t.skip_tokens_while(|c| c.is_digit(<span class="number">10</span>));
            <span class="kw">if </span>n_skipped == <span class="number">0 </span>{ <span class="prelude-val">None </span>} <span class="kw">else </span>{ <span class="prelude-val">Some</span>(()) }
        },
        |t| {
            t.context_mut().<span class="number">1 </span>+= <span class="number">1</span>;
            t.token(<span class="string">&#39;,&#39;</span>)
        }
    ).last();
    counts
}

<span class="kw">let </span>n: usize = <span class="number">0</span>;
<span class="kw">let </span><span class="kw-2">mut </span>tokens = <span class="string">&quot;123,4,56,1,34,1&quot;</span>.into_tokens();

<span class="kw">let </span>(digits, seps) = count_digit_comma_calls(<span class="kw-2">&amp;mut </span>tokens);

<span class="macro">assert_eq!</span>(tokens.remaining().len(), <span class="number">0</span>);
<span class="comment">// digits parsed 6 times:
</span><span class="macro">assert_eq!</span>(digits, <span class="number">6</span>);
<span class="comment">// Attempted to parse seps 6 times; failure on last ends it:
</span><span class="macro">assert_eq!</span>(seps, <span class="number">6</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.slice" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#203-205">source</a><h4 class="code-header">fn <a href="#method.slice" class="fn">slice</a>(&amp;mut self, from: Self::<a class="associatedtype" href="trait.Tokens.html#associatedtype.Location" title="type yap::Tokens::Location">Location</a>, to: Self::<a class="associatedtype" href="trait.Tokens.html#associatedtype.Location" title="type yap::Tokens::Location">Location</a>) -&gt; Slice&lt;'_, Self&gt;</h4></section></summary><div class="docblock"><p>Return a slice of tokens starting at the <code>to</code> location provided and ending just prior to
the <code>from</code> location provided (ie equivalent to the range <code>to..from</code>).</p>
<p>The slice returned from implements <a href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html" title="Iterator"><code>Iterator</code></a> and <a href="trait.Tokens.html" title="Tokens"><code>Tokens</code></a>, so you can use the full range
of parsing functions on it, or simply collect up the slice of tokens as you wish.</p>
<p><strong>Note:</strong> the slice returned from this prevents the original tokens from being used until
it’s dropped, and resets the original tokens to their current location on <code>Drop</code>. if you
<a href="https://doc.rust-lang.org/1.67.1/core/mem/fn.forget.html" title="std::mem::forget"><code>std::mem::forget</code></a> it, the original token location will equal whatever the slice location
was when it was forgotten.</p>
<h5 id="example-4"><a href="#example-4">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;abcdefghijklmnop&quot;</span>.into_tokens();

(<span class="number">0</span>..<span class="number">5</span>).for_each(|<span class="kw">_</span>| { s.next(); });
<span class="kw">let </span>from = s.location();
(<span class="number">0</span>..<span class="number">5</span>).for_each(|<span class="kw">_</span>| { s.next(); });
<span class="kw">let </span>to = s.location();

<span class="macro">assert_eq!</span>(s.next(), <span class="prelude-val">Some</span>(<span class="string">&#39;k&#39;</span>));
<span class="macro">assert_eq!</span>(s.next(), <span class="prelude-val">Some</span>(<span class="string">&#39;l&#39;</span>));

<span class="comment">// Iterating the from..to range given:
</span><span class="kw">let </span>vals: String = s.slice(from.clone(), to.clone()).collect();
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;*</span>vals, <span class="string">&quot;fghij&quot;</span>);

<span class="comment">// After the above is dropped, we can continue
// from where we left off:
</span><span class="macro">assert_eq!</span>(s.next(), <span class="prelude-val">Some</span>(<span class="string">&#39;m&#39;</span>));
<span class="macro">assert_eq!</span>(s.next(), <span class="prelude-val">Some</span>(<span class="string">&#39;n&#39;</span>));

<span class="comment">// We can iterate this range again as we please:
</span><span class="kw">let </span>vals: String = s.slice(from, to).collect();
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;*</span>vals, <span class="string">&quot;fghij&quot;</span>);

<span class="comment">// And the original remains unaffected..
</span><span class="macro">assert_eq!</span>(s.next(), <span class="prelude-val">Some</span>(<span class="string">&#39;o&#39;</span>));
<span class="macro">assert_eq!</span>(s.next(), <span class="prelude-val">Some</span>(<span class="string">&#39;p&#39;</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.offset" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#224-226">source</a><h4 class="code-header">fn <a href="#method.offset" class="fn">offset</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Return the current offset into the tokens that we’ve parsed up to so far.
The exact meaning of this can vary by implementation; when parsing slices, it
is index of the slice item we’ve consumed up to, and when
parsing <code>&amp;str</code>’s it is the number of bytes (not characters) consumed so far.</p>
<h5 id="example-5"><a href="#example-5">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;abc&quot;</span>.into_tokens();
<span class="macro">assert_eq!</span>(s.offset(), <span class="number">0</span>);
s.next();
<span class="macro">assert_eq!</span>(s.offset(), <span class="number">1</span>);
s.next();
<span class="macro">assert_eq!</span>(s.offset(), <span class="number">2</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.peek" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#242-247">source</a><h4 class="code-header">fn <a href="#method.peek" class="fn">peek</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;</h4></section></summary><div class="docblock"><p>Return the next item in the input without consuming it.</p>
<p>Prefer this to using the <code>peekable</code> iterator method, which consumes
the tokens, and internally keeps hold of the peeked state itself.</p>
<h5 id="example-6"><a href="#example-6">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;abc&quot;</span>.into_tokens();
<span class="macro">assert_eq!</span>(s.peek(), <span class="prelude-val">Some</span>(<span class="string">&#39;a&#39;</span>));
<span class="macro">assert_eq!</span>(s.peek(), <span class="prelude-val">Some</span>(<span class="string">&#39;a&#39;</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.token" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#264-277">source</a><h4 class="code-header">fn <a href="#method.token" class="fn">token</a>&lt;I&gt;(&amp;mut self, t: I) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.bool.html">bool</a><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;,</span></h4></section></summary><div class="docblock"><p>Expect a specific token to be next. If the token is not found, the iterator is not
advanced.</p>
<h5 id="example-7"><a href="#example-7">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;abc&quot;</span>.into_tokens();
<span class="macro">assert_eq!</span>(s.token(<span class="kw-2">&amp;</span><span class="string">&#39;a&#39;</span>), <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(s.token(<span class="kw-2">&amp;</span><span class="string">&#39;b&#39;</span>), <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(s.token(<span class="string">&#39;z&#39;</span>), <span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(s.token(<span class="string">&#39;y&#39;</span>), <span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(s.token(<span class="string">&#39;c&#39;</span>), <span class="bool-val">true</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tokens" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#296-312">source</a><h4 class="code-header">fn <a href="#method.tokens" class="fn">tokens</a>&lt;It&gt;(&amp;mut self, ts: It) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.bool.html">bool</a><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;It: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;It::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a>: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;,</span></h4></section></summary><div class="docblock"><p>Expect a specific set of tokens to be next. If the tokens are not found, the iterator is not
advanced. Anything that implements <code>IntoIterator</code> with an <code>Item</code> type that can be borrowed to
produce <code>&amp;Item</code> can be provided as an input to this.</p>
<h5 id="example-8"><a href="#example-8">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;abcdef&quot;</span>.into_tokens();

<span class="macro">assert_eq!</span>(s.tokens(<span class="string">&quot;abc&quot;</span>.chars()), <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(s.remaining(), <span class="string">&quot;def&quot;</span>);

<span class="macro">assert_eq!</span>(s.tokens(<span class="string">&quot;de&quot;</span>.chars()), <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(s.remaining(), <span class="string">&quot;f&quot;</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.one_of_tokens" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#330-348">source</a><h4 class="code-header">fn <a href="#method.one_of_tokens" class="fn">one_of_tokens</a>&lt;It&gt;(&amp;mut self, ts: It) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;It: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;It::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a>: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;,</span></h4></section></summary><div class="docblock"><p>Return the first token that matches the tokens provided, or None if none of them
match.</p>
<h5 id="example-9"><a href="#example-9">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;abcdef&quot;</span>.into_tokens();

<span class="macro">assert_eq!</span>(s.one_of_tokens(<span class="string">&quot;abc&quot;</span>.chars()), <span class="prelude-val">Some</span>(<span class="string">&#39;a&#39;</span>));
<span class="macro">assert_eq!</span>(s.one_of_tokens(<span class="string">&quot;abc&quot;</span>.chars()), <span class="prelude-val">Some</span>(<span class="string">&#39;b&#39;</span>));
<span class="macro">assert_eq!</span>(s.one_of_tokens(<span class="string">&quot;abc&quot;</span>.chars()), <span class="prelude-val">Some</span>(<span class="string">&#39;c&#39;</span>));
<span class="macro">assert_eq!</span>(s.one_of_tokens(<span class="string">&quot;abc&quot;</span>.chars()), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(s.remaining(), <span class="string">&quot;def&quot;</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tokens_while" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#362-367">source</a><h4 class="code-header">fn <a href="#method.tokens_while" class="fn">tokens_while</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; TokensWhile&lt;'_, Self, F&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Return an iterator that will consume tokens until the provided function returns false.</p>
<h5 id="example-10"><a href="#example-10">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;12345abc&quot;</span>.into_tokens();
<span class="kw">let </span>digits: String = s.tokens_while(|c| c.is_numeric()).collect();
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;*</span>digits, <span class="string">&quot;12345&quot;</span>);
<span class="macro">assert_eq!</span>(s.remaining(), <span class="string">&quot;abc&quot;</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.skip_tokens_while" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#383-388">source</a><h4 class="code-header">fn <a href="#method.skip_tokens_while" class="fn">skip_tokens_while</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.usize.html">usize</a><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Iterate over the tokens until the provided function returns false on one.
Only consume the tokens that the function returned true for, and ignore them.</p>
<h5 id="example-11"><a href="#example-11">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;12345abc&quot;</span>.into_tokens();
<span class="kw">let </span>n_skipped = s.skip_tokens_while(|c| c.is_numeric());

<span class="macro">assert_eq!</span>(n_skipped, <span class="number">5</span>);
<span class="macro">assert_eq!</span>(s.remaining(), <span class="string">&quot;abc&quot;</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.many" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#411-416">source</a><h4 class="code-header">fn <a href="#method.many" class="fn">many</a>&lt;F, Output&gt;(&amp;mut self, parser: F) -&gt; Many&lt;'_, Self, F&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Output&gt;,</span></h4></section></summary><div class="docblock"><p>Returns an iterator that, on each iteration, attempts to run the provided parser
on the remaining tokens. If the parser returns <a href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html#variant.None" title="None"><code>None</code></a>, no tokens will be consumed.</p>
<h5 id="example-12"><a href="#example-12">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="kw">fn </span>parse_digit_pair(tokens: <span class="kw-2">&amp;mut </span><span class="kw">impl </span>Tokens&lt;Item=char&gt;) -&gt; <span class="prelude-ty">Option</span>&lt;u32&gt; {
    <span class="kw">let </span>d1 = tokens.next()<span class="question-mark">?</span>;
    <span class="kw">let </span>d2 = tokens.next()<span class="question-mark">?</span>;
    <span class="comment">// Return the result of adding the 2 digits we saw:
    </span><span class="prelude-val">Some</span>(d1.to_digit(<span class="number">10</span>)<span class="question-mark">? </span>+ d2.to_digit(<span class="number">10</span>)<span class="question-mark">?</span>)
}

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;12345abcde&quot;</span>.into_tokens();
<span class="kw">let </span>digits: Vec&lt;u32&gt; = s.many(|t| parse_digit_pair(t)).collect();

<span class="macro">assert_eq!</span>(digits, <span class="macro">vec!</span>[<span class="number">3</span>, <span class="number">7</span>]);
<span class="macro">assert_eq!</span>(s.remaining(), <span class="string">&quot;5abcde&quot;</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.many_err" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#448-453">source</a><h4 class="code-header">fn <a href="#method.many_err" class="fn">many_err</a>&lt;F, Output, E&gt;(&amp;mut self, parser: F) -&gt; ManyErr&lt;'_, Self, F&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Output, E&gt;,</span></h4></section></summary><div class="docblock"><p>Returns an iterator that, on each iteration, attempts to run the provided parser
on the remaining tokens. If the parser returns an error, no tokens will be consumed
and the error will be returned as the final iteration.</p>
<h5 id="example-13"><a href="#example-13">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="attr">#[derive(Debug, PartialEq)]
</span><span class="kw">enum </span><span class="prelude-val">Err </span>{ NotEnoughTokens, NotADigit(char) }
<span class="kw">fn </span>parse_digit_pair(tokens: <span class="kw-2">&amp;mut </span><span class="kw">impl </span>Tokens&lt;Item=char&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;u32, <span class="prelude-val">Err</span>&gt; {
    <span class="kw">let </span>n1 = tokens.next()
        .ok_or(Err::NotEnoughTokens)
        .and_then(|c| c.to_digit(<span class="number">10</span>).ok_or(Err::NotADigit(c)))<span class="question-mark">?</span>;
    <span class="kw">let </span>n2 = tokens.next()
        .ok_or(Err::NotEnoughTokens)
        .and_then(|c| c.to_digit(<span class="number">10</span>).ok_or(Err::NotADigit(c)))<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(n1 + n2)
}

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;12345abcde&quot;</span>.into_tokens();
<span class="kw">let </span><span class="kw-2">mut </span>digits_iter = s.many_err(|t| parse_digit_pair(t));

<span class="macro">assert_eq!</span>(digits_iter.next(), <span class="prelude-val">Some</span>(<span class="prelude-val">Ok</span>(<span class="number">3</span>)));
<span class="macro">assert_eq!</span>(digits_iter.next(), <span class="prelude-val">Some</span>(<span class="prelude-val">Ok</span>(<span class="number">7</span>)));
<span class="macro">assert_eq!</span>(digits_iter.next(), <span class="prelude-val">Some</span>(<span class="prelude-val">Err</span>(Err::NotADigit(<span class="string">&#39;a&#39;</span>))));
<span class="macro">assert_eq!</span>(digits_iter.next(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(s.remaining(), <span class="string">&quot;5abcde&quot;</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.skip_many" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#479-484">source</a><h4 class="code-header">fn <a href="#method.skip_many" class="fn">skip_many</a>&lt;F&gt;(&amp;mut self, parser: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.usize.html">usize</a><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Ignore 0 or more instances of some parser.</p>
<h5 id="example-14"><a href="#example-14">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="kw">struct </span>ABC;
<span class="kw">fn </span>parse_abc(tokens: <span class="kw-2">&amp;mut </span><span class="kw">impl </span>Tokens&lt;Item=char&gt;) -&gt; <span class="prelude-ty">Option</span>&lt;ABC&gt; {
    <span class="kw">let </span>a = tokens.next()<span class="question-mark">?</span>;
    <span class="kw">let </span>b = tokens.next()<span class="question-mark">?</span>;
    <span class="kw">let </span>c = tokens.next()<span class="question-mark">?</span>;
    <span class="kw">if </span>a == <span class="string">&#39;a&#39; </span>&amp;&amp; b == <span class="string">&#39;b&#39; </span>&amp;&amp; c == <span class="string">&#39;c&#39; </span>{
        <span class="prelude-val">Some</span>(ABC)
    } <span class="kw">else </span>{
        <span class="prelude-val">None
    </span>}
}

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;abcabcababab&quot;</span>.into_tokens();
s.skip_many(|t| parse_abc(t).is_some());

<span class="macro">assert_eq!</span>(s.remaining(), <span class="string">&quot;ababab&quot;</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.skip_many1" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#518-533">source</a><h4 class="code-header">fn <a href="#method.skip_many1" class="fn">skip_many1</a>&lt;F, E, Ignored&gt;(&amp;mut self, parser: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.usize.html">usize</a>, E&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Ignored, E&gt;,</span></h4></section></summary><div class="docblock"><p>Ignore 1 or more instances of some parser. If the provided parser
fails immediately, return the error that it produced.</p>
<h5 id="example-15"><a href="#example-15">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="kw">struct </span>ABC;
<span class="kw">fn </span>parse_abc(tokens: <span class="kw-2">&amp;mut </span><span class="kw">impl </span>Tokens&lt;Item=char&gt;) -&gt; <span class="prelude-ty">Option</span>&lt;ABC&gt; {
    <span class="kw">let </span>a = tokens.next()<span class="question-mark">?</span>;
    <span class="kw">let </span>b = tokens.next()<span class="question-mark">?</span>;
    <span class="kw">let </span>c = tokens.next()<span class="question-mark">?</span>;
    <span class="kw">if </span>a == <span class="string">&#39;a&#39; </span>&amp;&amp; b == <span class="string">&#39;b&#39; </span>&amp;&amp; c == <span class="string">&#39;c&#39; </span>{
        <span class="prelude-val">Some</span>(ABC)
    } <span class="kw">else </span>{
        <span class="prelude-val">None
    </span>}
}

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;abcabcabcxyz&quot;</span>.into_tokens();
<span class="kw">let </span>skipped = s.skip_many1(|t| parse_abc(t).ok_or(<span class="string">&quot;aaah&quot;</span>));

<span class="macro">assert_eq!</span>(skipped, <span class="prelude-val">Ok</span>(<span class="number">3</span>));
<span class="macro">assert_eq!</span>(s.remaining(), <span class="string">&quot;xyz&quot;</span>);

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;ababababcabc&quot;</span>.into_tokens();
<span class="kw">let </span>skipped = s.skip_many1(|t| parse_abc(t).ok_or(<span class="string">&quot;aaah&quot;</span>));

<span class="macro">assert_eq!</span>(skipped, <span class="prelude-val">Err</span>(<span class="string">&quot;aaah&quot;</span>));
<span class="macro">assert_eq!</span>(s.remaining(), <span class="string">&quot;ababababcabc&quot;</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.sep_by" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#553-559">source</a><h4 class="code-header">fn <a href="#method.sep_by" class="fn">sep_by</a>&lt;F, S, Output&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self,<br>&nbsp;&nbsp;&nbsp;&nbsp;parser: F,<br>&nbsp;&nbsp;&nbsp;&nbsp;separator: S<br>) -&gt; SepBy&lt;'_, Self, F, S&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Output&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Return an iterator that parses anything matching the <code>parser</code> function, and expects
to parse something matching the <code>separator</code> function between each one.</p>
<h5 id="example-16"><a href="#example-16">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="kw">fn </span>parse_digit(tokens: <span class="kw-2">&amp;mut </span><span class="kw">impl </span>Tokens&lt;Item=char&gt;) -&gt; <span class="prelude-ty">Option</span>&lt;u32&gt; {
    <span class="kw">let </span>c = tokens.next()<span class="question-mark">?</span>;
    c.to_digit(<span class="number">10</span>)
}

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;1,2,3,4,abc&quot;</span>.into_tokens();
<span class="kw">let </span>digits: Vec&lt;u32&gt; = s.sep_by(|t| parse_digit(t), |t| t.token(<span class="string">&#39;,&#39;</span>)).collect();
<span class="macro">assert_eq!</span>(digits, <span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);
<span class="macro">assert_eq!</span>(s.remaining(), <span class="string">&quot;,abc&quot;</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.sep_by_err" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#587-593">source</a><h4 class="code-header">fn <a href="#method.sep_by_err" class="fn">sep_by_err</a>&lt;F, S, E, Output&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self,<br>&nbsp;&nbsp;&nbsp;&nbsp;parser: F,<br>&nbsp;&nbsp;&nbsp;&nbsp;separator: S<br>) -&gt; SepByErr&lt;'_, Self, F, S&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Output, E&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Return an iterator that parses anything matching the <code>parser</code> function, and expects
to parse something matching the <code>separator</code> function between each one. Unlike <a href="trait.Tokens.html#method.sep_by" title="Tokens::sep_by"><code>Tokens::sep_by</code></a>,
this accepts parsers that return <code>Result</code>s, and returns the result on each iteration. Once
an error is hit, <code>None</code> is returned thereafter.</p>
<h5 id="example-17"><a href="#example-17">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="attr">#[derive(Debug, PartialEq)]
</span><span class="kw">enum </span><span class="prelude-val">Err </span>{ NoMoreTokens, NotADigit(char) }

<span class="kw">fn </span>parse_digit(tokens: <span class="kw-2">&amp;mut </span><span class="kw">impl </span>Tokens&lt;Item=char&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;u32, <span class="prelude-val">Err</span>&gt; {
    <span class="kw">let </span>c = tokens.next().ok_or(Err::NoMoreTokens)<span class="question-mark">?</span>;
    c.to_digit(<span class="number">10</span>).ok_or(Err::NotADigit(c))
}

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;1,2,a,1,2,3&quot;</span>.into_tokens();
<span class="kw">let </span><span class="kw-2">mut </span>digits_iter = s.sep_by_err(|t| parse_digit(t), |t| t.token(<span class="string">&#39;,&#39;</span>));
<span class="macro">assert_eq!</span>(digits_iter.next(), <span class="prelude-val">Some</span>(<span class="prelude-val">Ok</span>(<span class="number">1</span>)));
<span class="macro">assert_eq!</span>(digits_iter.next(), <span class="prelude-val">Some</span>(<span class="prelude-val">Ok</span>(<span class="number">2</span>)));
<span class="macro">assert_eq!</span>(digits_iter.next(), <span class="prelude-val">Some</span>(<span class="prelude-val">Err</span>(Err::NotADigit(<span class="string">&#39;a&#39;</span>))));
<span class="macro">assert_eq!</span>(digits_iter.next(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(s.remaining(), <span class="string">&quot;,a,1,2,3&quot;</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.sep_by_all" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#641-647">source</a><h4 class="code-header">fn <a href="#method.sep_by_all" class="fn">sep_by_all</a>&lt;F, S, Output&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self,<br>&nbsp;&nbsp;&nbsp;&nbsp;parser: F,<br>&nbsp;&nbsp;&nbsp;&nbsp;separator: S<br>) -&gt; SepByAll&lt;'_, Self, F, S, Output&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Output&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Output&gt;,</span></h4></section></summary><div class="docblock"><p>Returns an iterator that parses anything matching the <code>parser</code> function,
and expects to parse something matching the <code>separator</code> function between each one.
The iterator returns the output from both the <code>parser</code> and <code>separator</code> function,
which means that they are expected to return the same type.</p>
<h5 id="example-18"><a href="#example-18">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="attr">#[derive(PartialEq,Debug)]
</span><span class="kw">enum </span>Op { Plus, Minus, Divide }
<span class="attr">#[derive(PartialEq,Debug)]
</span><span class="kw">enum </span>OpOrDigit { Op(Op), Digit(u32) }

<span class="kw">fn </span>parse_op(tokens: <span class="kw-2">&amp;mut </span><span class="kw">impl </span>Tokens&lt;Item=char&gt;) -&gt; <span class="prelude-ty">Option</span>&lt;Op&gt; {
    <span class="kw">match </span>tokens.next()<span class="question-mark">? </span>{
        <span class="string">&#39;-&#39; </span>=&gt; <span class="prelude-val">Some</span>(Op::Minus),
        <span class="string">&#39;+&#39; </span>=&gt; <span class="prelude-val">Some</span>(Op::Plus),
        <span class="string">&#39;/&#39; </span>=&gt; <span class="prelude-val">Some</span>(Op::Divide),
        <span class="kw">_ </span>=&gt; <span class="prelude-val">None
    </span>}
}

<span class="kw">fn </span>parse_digit(tokens: <span class="kw-2">&amp;mut </span><span class="kw">impl </span>Tokens&lt;Item=char&gt;) -&gt; <span class="prelude-ty">Option</span>&lt;u32&gt; {
    <span class="kw">let </span>c = tokens.next()<span class="question-mark">?</span>;
    c.to_digit(<span class="number">10</span>)
}

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;1+2/3-4+abc&quot;</span>.into_tokens();
<span class="kw">let </span>output: Vec&lt;<span class="kw">_</span>&gt; = s.sep_by_all(
    |t| parse_digit(t).map(OpOrDigit::Digit),
    |t| parse_op(t).map(OpOrDigit::Op)
).collect();

<span class="macro">assert_eq!</span>(output, <span class="macro">vec!</span>[
    OpOrDigit::Digit(<span class="number">1</span>),
    OpOrDigit::Op(Op::Plus),
    OpOrDigit::Digit(<span class="number">2</span>),
    OpOrDigit::Op(Op::Divide),
    OpOrDigit::Digit(<span class="number">3</span>),
    OpOrDigit::Op(Op::Minus),
    OpOrDigit::Digit(<span class="number">4</span>),
]);
<span class="macro">assert_eq!</span>(s.remaining(), <span class="string">&quot;+abc&quot;</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.sep_by_all_err" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#696-702">source</a><h4 class="code-header">fn <a href="#method.sep_by_all_err" class="fn">sep_by_all_err</a>&lt;F, S, Output, E&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self,<br>&nbsp;&nbsp;&nbsp;&nbsp;parser: F,<br>&nbsp;&nbsp;&nbsp;&nbsp;separator: S<br>) -&gt; SepByAllErr&lt;'_, Self, F, S, Output&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Output, E&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Output&gt;,</span></h4></section></summary><div class="docblock"><p>Similar to <a href="trait.Tokens.html#method.sep_by_all" title="Tokens::sep_by_all"><code>Tokens::sep_by_all</code></a>, except that the iterator returned also hands back
the first error encountered when attempting to run our <code>parser</code>.</p>
<h5 id="example-19"><a href="#example-19">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="attr">#[derive(PartialEq,Debug)]
</span><span class="kw">enum </span>Op { Plus, Minus, Divide }
<span class="attr">#[derive(PartialEq,Debug)]
</span><span class="kw">enum </span>OpOrDigit { Op(Op), Digit(u32) }
<span class="attr">#[derive(Debug, PartialEq)]
</span><span class="kw">enum </span><span class="prelude-val">Err </span>{ NoMoreTokens, NotADigit(char) }

<span class="kw">fn </span>parse_op(tokens: <span class="kw-2">&amp;mut </span><span class="kw">impl </span>Tokens&lt;Item=char&gt;) -&gt; <span class="prelude-ty">Option</span>&lt;Op&gt; {
    <span class="kw">match </span>tokens.next()<span class="question-mark">? </span>{
        <span class="string">&#39;-&#39; </span>=&gt; <span class="prelude-val">Some</span>(Op::Minus),
        <span class="string">&#39;+&#39; </span>=&gt; <span class="prelude-val">Some</span>(Op::Plus),
        <span class="string">&#39;/&#39; </span>=&gt; <span class="prelude-val">Some</span>(Op::Divide),
        <span class="kw">_ </span>=&gt; <span class="prelude-val">None
    </span>}
}

<span class="kw">fn </span>parse_digit(tokens: <span class="kw-2">&amp;mut </span><span class="kw">impl </span>Tokens&lt;Item=char&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;u32, <span class="prelude-val">Err</span>&gt; {
    <span class="kw">let </span>c = tokens.next().ok_or(Err::NoMoreTokens)<span class="question-mark">?</span>;
    c.to_digit(<span class="number">10</span>).ok_or(Err::NotADigit(c))
}

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;1+2/3-4+abc&quot;</span>.into_tokens();
<span class="kw">let </span>output: Vec&lt;<span class="kw">_</span>&gt; = s.sep_by_all_err(
    |t| parse_digit(t).map(OpOrDigit::Digit),
    |t| parse_op(t).map(OpOrDigit::Op)
).collect();

<span class="macro">assert_eq!</span>(output, <span class="macro">vec!</span>[
    <span class="prelude-val">Ok</span>(OpOrDigit::Digit(<span class="number">1</span>)),
    <span class="prelude-val">Ok</span>(OpOrDigit::Op(Op::Plus)),
    <span class="prelude-val">Ok</span>(OpOrDigit::Digit(<span class="number">2</span>)),
    <span class="prelude-val">Ok</span>(OpOrDigit::Op(Op::Divide)),
    <span class="prelude-val">Ok</span>(OpOrDigit::Digit(<span class="number">3</span>)),
    <span class="prelude-val">Ok</span>(OpOrDigit::Op(Op::Minus)),
    <span class="prelude-val">Ok</span>(OpOrDigit::Digit(<span class="number">4</span>)),
    <span class="prelude-val">Err</span>(Err::NotADigit(<span class="string">&#39;a&#39;</span>))
]);
<span class="macro">assert_eq!</span>(s.remaining(), <span class="string">&quot;+abc&quot;</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.surrounded_by" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#721-730">source</a><h4 class="code-header">fn <a href="#method.surrounded_by" class="fn">surrounded_by</a>&lt;F, S, Output&gt;(&amp;mut self, parser: F, surrounding: S) -&gt; Output<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; Output,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self),</span></h4></section></summary><div class="docblock"><p>Parse some tokens that are optionally surrounded by the result of a <code>surrounding</code> parser.</p>
<h5 id="example-20"><a href="#example-20">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;   hello    &quot;</span>.into_tokens();

<span class="kw">let </span>hello: String = s.surrounded_by(
    |t| t.tokens_while(|c| c.is_ascii_alphabetic()).collect(),
    |t| { t.skip_tokens_while(|c| c.is_ascii_whitespace()); }
);

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;*</span>hello, <span class="string">&quot;hello&quot;</span>);
<span class="macro">assert_eq!</span>(s.remaining(), <span class="string">&quot;&quot;</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.optional" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#766-776">source</a><h4 class="code-header">fn <a href="#method.optional" class="fn">optional</a>&lt;F, Output&gt;(&amp;mut self, f: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Output&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Output&gt;,</span></h4></section></summary><div class="docblock"><p>Attempt to parse some output from the tokens. If the function returns <code>None</code>,
no tokens will be consumed. Else, return whatever the function produced.</p>
<h5 id="example-21"><a href="#example-21">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;foobar&quot;</span>.into_tokens();

<span class="kw">let </span>res = s.optional(|s| {
    <span class="kw">let </span>a = s.next();
    <span class="kw">let </span>b = s.next();
    <span class="kw">if </span>a == b {
        <span class="prelude-val">Some</span>(<span class="string">&quot;yay&quot;</span>)
    } <span class="kw">else </span>{
        <span class="prelude-val">None
    </span>}
});

<span class="comment">// nothing consumed since None returned from fn
</span><span class="macro">assert_eq!</span>(s.remaining(), <span class="string">&quot;foobar&quot;</span>);
<span class="macro">assert_eq!</span>(res, <span class="prelude-val">None</span>);

<span class="kw">let </span>res = s.optional(|s| {
    <span class="kw">let </span>a = s.next()<span class="question-mark">?</span>;
    <span class="kw">let </span>b = s.next()<span class="question-mark">?</span>;
    <span class="prelude-val">Some</span>((a, b))
});

<span class="comment">// 2 chars consumed since Some returned from fn
</span><span class="macro">assert_eq!</span>(s.remaining(), <span class="string">&quot;obar&quot;</span>);
<span class="macro">assert_eq!</span>(res, <span class="prelude-val">Some</span>((<span class="string">&#39;f&#39;</span>, <span class="string">&#39;o&#39;</span>)));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.skip_optional" class="method has-srclink"><a class="srclink rightside" href="../src/yap/tokens.rs.html#800-806">source</a><h4 class="code-header">fn <a href="#method.skip_optional" class="fn">skip_optional</a>&lt;F&gt;(&amp;mut self, f: F)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>Self),</span></h4></section></summary><div class="docblock"><p>Run a parser against some tokens, and don’t care whether it succeeded
or how much input it consumed.</p>
<h5 id="example-22"><a href="#example-22">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yap::{ Tokens, IntoTokens };

<span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">&quot;   helloworld&quot;</span>.into_tokens();

<span class="kw">fn </span>parse_whitespace(t: <span class="kw-2">&amp;mut </span><span class="kw">impl </span>Tokens&lt;Item=char&gt;) {
    t.skip_tokens_while(|c| c.is_ascii_whitespace());
}

s.skip_optional(|t| parse_whitespace(t));
<span class="kw">let </span>is_hello = s.tokens(<span class="string">&quot;hello&quot;</span>.chars());
s.skip_optional(|t| parse_whitespace(t));
<span class="kw">let </span>world: String = s.tokens_while(|c| c.is_ascii_alphabetic()).collect();

<span class="comment">// assert_eq!(is_hello, true);
// assert_eq!(&amp;*world, &quot;world&quot;);</span></code></pre></div>
</div></details></div><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Tokens-for-StrTokens%3C%27a%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/yap/types.rs.html#143-155">source</a><a href="#impl-Tokens-for-StrTokens%3C%27a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="trait.Tokens.html" title="trait yap::Tokens">Tokens</a> for <a class="struct" href="types/struct.StrTokens.html" title="struct yap::types::StrTokens">StrTokens</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><section id="associatedtype.Location-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Location-1" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Location" class="associatedtype">Location</a> = <a class="struct" href="types/struct.StrTokensLocation.html" title="struct yap::types::StrTokensLocation">StrTokensLocation</a></h4></section></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Tokens-for-SliceTokens%3C%27a%2C%20Item%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/yap/types.rs.html#52-64">source</a><a href="#impl-Tokens-for-SliceTokens%3C%27a%2C%20Item%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, Item&gt; <a class="trait" href="trait.Tokens.html" title="trait yap::Tokens">Tokens</a> for <a class="struct" href="types/struct.SliceTokens.html" title="struct yap::types::SliceTokens">SliceTokens</a>&lt;'a, Item&gt;</h3></section></summary><div class="impl-items"><section id="associatedtype.Location-2" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Location-2" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Location" class="associatedtype">Location</a> = <a class="struct" href="types/struct.SliceTokensLocation.html" title="struct yap::types::SliceTokensLocation">SliceTokensLocation</a></h4></section></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Tokens-for-WithContext%3CT%2C%20C%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/yap/types.rs.html#241">source</a><a href="#impl-Tokens-for-WithContext%3CT%2C%20C%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, C&gt; <a class="trait" href="trait.Tokens.html" title="trait yap::Tokens">Tokens</a> for <a class="struct" href="types/struct.WithContext.html" title="struct yap::types::WithContext">WithContext</a>&lt;T, C&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="trait.Tokens.html" title="trait yap::Tokens">Tokens</a>,</span></h3></section></summary><div class="impl-items"><section id="associatedtype.Location-3" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Location-3" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Location" class="associatedtype">Location</a> = &lt;T as <a class="trait" href="trait.Tokens.html" title="trait yap::Tokens">Tokens</a>&gt;::<a class="associatedtype" href="trait.Tokens.html#associatedtype.Location" title="type yap::Tokens::Location">Location</a></h4></section></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Tokens-for-WithContextMut%3C%26mut%20T%2C%20C%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/yap/types.rs.html#242">source</a><a href="#impl-Tokens-for-WithContextMut%3C%26mut%20T%2C%20C%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, C&gt; <a class="trait" href="trait.Tokens.html" title="trait yap::Tokens">Tokens</a> for <a class="struct" href="types/struct.WithContextMut.html" title="struct yap::types::WithContextMut">WithContextMut</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>T, C&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="trait.Tokens.html" title="trait yap::Tokens">Tokens</a>,</span></h3></section></summary><div class="impl-items"><section id="associatedtype.Location-4" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Location-4" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Location" class="associatedtype">Location</a> = &lt;T as <a class="trait" href="trait.Tokens.html" title="trait yap::Tokens">Tokens</a>&gt;::<a class="associatedtype" href="trait.Tokens.html#associatedtype.Location" title="type yap::Tokens::Location">Location</a></h4></section></div></details></div><script src="../implementors/yap/tokens/trait.Tokens.js" async></script><script type="text/json" id="notable-traits-data">{"WithContext<Self, C>":"<h3>Notable traits for <code><a class=\"struct\" href=\"types/struct.WithContext.html\" title=\"struct yap::types::WithContext\">WithContext</a>&lt;T, C&gt;</code></h3><pre class=\"content\"><code><span class=\"where fmt-newline\">impl&lt;T, C&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"types/struct.WithContext.html\" title=\"struct yap::types::WithContext\">WithContext</a>&lt;T, C&gt;<span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>,</span></span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = T::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" title=\"type core::iter::traits::iterator::Iterator::Item\">Item</a>;</span>","WithContextMut<&mut Self, C>":"<h3>Notable traits for <code><a class=\"struct\" href=\"types/struct.WithContextMut.html\" title=\"struct yap::types::WithContextMut\">WithContextMut</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.67.1/std/primitive.reference.html\">&amp;mut </a>T, C&gt;</code></h3><pre class=\"content\"><code><span class=\"where fmt-newline\">impl&lt;T, C&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"types/struct.WithContextMut.html\" title=\"struct yap::types::WithContextMut\">WithContextMut</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.67.1/std/primitive.reference.html\">&amp;mut </a>T, C&gt;<span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>,</span></span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = T::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.67.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" title=\"type core::iter::traits::iterator::Iterator::Item\">Item</a>;</span>"}</script></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="yap" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.1 (d5a82bbd2 2023-02-07)" data-search-js="search-444266647c4dba98.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>